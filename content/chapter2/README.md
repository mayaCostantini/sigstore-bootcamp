# Chapter 2: How does Sigstore work? Introduction to Sigstore subprojects

## Overview of Sigstore main components

Sigstore is composed of multiple subprojects, libraries and clients available under the [GitHub Sigstore organization](https://github.com/sigstore).
Generally speaking, the Sigstore signing and verifying workflows are enabled by three main components:

- [Cosign](https://docs.sigstore.dev/cosign/overview/) (or other language-specific Sigstore clients), a CLI that performs the signing and verification workflows
- [Rekor](https://docs.sigstore.dev/rekor/overview/), a Transparency Log used to store signatures and their metadata
- [Fulcio](https://docs.sigstore.dev/fulcio/overview/), a free Certificate Authority (CA) that delivers ephemeral x509 signing certificates

Sigstore Cosign's interface is straightforward to use for basic signing workflows.
To sign a container image using a private key, one can simply run:

```
cosign sign --key cosign.key <IMAGE DIGEST>
```

Where `cosign.key` is a signing key that can be generated using Cosign.


## Sigstore's "keyless" signing workflow

One of the new innovative features introduced by Sigstore is **"keyless"** signing.
In addition to the key-signing process described above, this workflow allows users to sign an artifact without a permanent self-managed private key,
using an **identity** instead (for example, an email address) provided by a trusted party.

Keyless signing solves the issue of private key management by removing the need to securely store a private key on the client side,
as it is the case for example for GPG.
This means users do not need to care anymore about issues such as key revocation or rotation in case of leak.

But how does "keyless" signing work?

This Sigstore workflow is "keyless" kind of the same way serverless is "serverless":
under the hood, a private-public key pair is generated by Sigstore to sign the artifact, but those keys are **ephemeral**,
which means that they stay in memory during the whole signing process and never hit the disk.

For those of you who are somehow familiar with asymmetric cryptography, you might wonder what happens to the public key
that is normally used to verify the signature authenticity.

Here is a high-level overview of how the "keyless" signing workflow works:

- Step 1: Cosign (or the client) generates a pair of private-public keys in memory
- Step 2: Cosign gets a proof of the user's identity from an OpenID Connect (OIDC) provider, such as GitHub, Microsoft or Google.
In this step, the user is prompted to authenticate via a browser window to one of the configured providers 
- Step 3: The verified user identity is embedded in an ephemeral x509 certificate along with the generated public key,
and this certificate is sent to the Fulcio CA
- Step 4: Fulcio signs the certificate, logs it into its own Transparency Log and sends it back to the client
- Step 5: The certificate is verified by the client and used (within its 10min window of validity) to sign the artifacts
- Step 6: A signature entry with metadata is logged into the Rekor transparency log as a proof of signing kept by Sigstore
- Step 7: The process terminates: the ephemeral key pair is flushed from memory and the client outputs the **Sigstore verification materials**:
the signature file, the ephemeral signing certificate and eventually a JSON file called a Sigstore bundle that contains
all the necessary information to verify a signature offline.

To verify a signature, Cosign needs the signature and certificate files and proceeds the following way:

- Look for the public key embedded in the certificate and verify that the signature corresponds to the associated private key
- Verify that the OpenID Connect identity and provider are the ones expected
- Fetch the corresponding signature entry from Rekor to verify if it has been included the Transparency Log and check the signature timestamp:
if the timestamp is included in the certificate window of validity, then the signature is validated.


![Overview of the Sigstore keyless signing workflow](assets/how_does_sigstore_work.jpg)


In summary, here are some advantages provided by the keyless workflow compared to signing with a managed key pair:

- **Private key management:** no more need from users to keep a private key securely stored for signing,
which can get expensive and facilitate key leaks if not done correctly

- **Key rotation:** in the same way, the ephemeral key eliminates the need to rotate the signing key if this one gets compromised

- **Public key distribution:** an issue with current signing schemes like GPG is the process of associating a public key
to its owner's (individual or organization) identity: when using a public to verify a package signature, how do you really
ensure this private key belongs to the publisher? How to verify if the key has been revoked in the meantime?
With keyless signing, public keys are embedded in the certificates that attest of the signer's identity

- **Stronger authentication:** using OpenID Connect to authenticate to Sigstore means that you can define a custom level of authentication security
according to features available via your identity provided, for example Multi-Factor Authentication (MFA).


_Resources:_

- [Public Key (or asymmetric) cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)
- [The X509 format](https://en.wikipedia.org/wiki/X.509)